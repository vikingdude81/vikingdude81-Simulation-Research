Totally. This is a perfect “small but fancy” Python project.

Here’s a straight shot you can paste into a notebook / VS Code / Replit that:

1. defines the 1D harmonic-oscillator wavefunction (\psi_n(x)),
2. builds the 2D one (\psi_{n_x,n_y}(x,y) = \psi_{n_x}(x)\psi_{n_y}(y)),
3. plots it as a 3D surface.

I’ll give you a version that uses **NumPy + SciPy + Matplotlib** (most common stack). After that I’ll tell you how to do it without SciPy.

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # needed for 3D
from scipy.special import hermite, factorial
from math import pi, sqrt

# ---------------------------
# 1. 1D harmonic oscillator ψ_n(x)
# ---------------------------
def psi_n(x, n):
    """
    Harmonic oscillator eigenfunction (m=ω=ħ=1 units):
    ψ_n(x) = (1 / sqrt(2^n n! sqrt(pi))) * H_n(x) * exp(-x^2 / 2)
    """
    Hn = hermite(n)        # returns a poly object
    norm = 1.0 / np.sqrt((2.0**n) * factorial(n) * np.sqrt(pi))
    return norm * np.exp(-x**2 / 2.0) * Hn(x)

# ---------------------------
# 2. 2D wavefunction ψ_{nx,ny}(x,y) = ψ_nx(x)*ψ_ny(y)
# ---------------------------
def psi_2d(x, y, nx, ny):
    return psi_n(x, nx) * psi_n(y, ny)

# choose quantum numbers
nx = 2
ny = 1

# grid to evaluate on
x = np.linspace(-4, 4, 200)
y = np.linspace(-4, 4, 200)
X, Y = np.meshgrid(x, y)

Z = psi_2d(X, Y, nx, ny)  # this is the wavefunction
# You could also look at probability density:
# Z = np.abs(Z)**2

# ---------------------------
# 3. Plot
# ---------------------------
fig = plt.figure(figsize=(7, 5))
ax = fig.add_subplot(111, projection='3d')

ax.plot_surface(X, Y, Z, rstride=4, cstride=4, linewidth=0, antialiased=True)

ax.set_title(f"2D Quantum Harmonic Oscillator ψ({nx},{ny})")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("ψ")
plt.show()
```

That will spit out a 3D “wavy” shape similar in spirit to the one in the tweet (the styling is different, but it’s the same math).

---

### If you don’t want SciPy

You can build Hermite polynomials by recurrence:

```python
def hermite_phys(n, x):
    # "physics" Hermite polynomials
    if n == 0:
        return np.ones_like(x)
    if n == 1:
        return 2*x
    Hnm2 = np.ones_like(x)
    Hnm1 = 2*x
    for k in range(2, n+1):
        Hn = 2*x*Hnm1 - 2*(k-1)*Hnm2
        Hnm2, Hnm1 = Hnm1, Hn
    return Hn
```

and then plug that into the same formula.

---

### Want it interactive?

* In a Jupyter notebook you can add a slider (with `ipywidgets`) to change `nx` and `ny` live.
* Or in Replit you can just rerun with different `nx, ny`.

If you tell me “I only have plain Python, no SciPy” or “I want a 2D contour/heatmap instead of 3D,” I can drop that version too.
