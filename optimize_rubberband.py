"""
Parameter Optimizer for Rubber-Band Reversion Indicator

Tests different parameter combinations to find optimal settings for:
- Each asset individually (BTC/ETH/SOL)
- Best universal settings across all assets
"""

import pandas as pd
import numpy as np
from rubberband_indicator import RubberBandOscillator
from itertools import product
import json
from datetime import datetime


class RubberBandOptimizer:
    """
    Optimize Rubber-Band indicator parameters using backtesting
    """
    
    def __init__(self, assets=['BTC', 'ETH', 'SOL']):
        self.assets = assets
        self.data = {}
        self.results = []
    
    def load_data(self):
        """Load historical data for all assets"""
        print("\nüìä Loading data...")
        
        for asset in self.assets:
            file_path = f"DATA/yf_{asset.lower()}_1h.csv"
            try:
                df = pd.read_csv(file_path)
                df['time'] = pd.to_datetime(df['time'])
                
                # Standardize column names
                if 'Close' in df.columns:
                    df = df.rename(columns={
                        'Open': 'open', 'High': 'high', 
                        'Low': 'low', 'Close': 'close', 'Volume': 'volume'
                    })
                
                # Take last 90 days for optimization
                df = df.tail(90 * 24).reset_index(drop=True)
                
                self.data[asset] = df
                print(f"   ‚úÖ {asset}: {len(df)} bars ({df['time'].min().date()} to {df['time'].max().date()})")
            except Exception as e:
                print(f"   ‚ùå {asset}: Failed to load - {e}")
        
        return len(self.data) > 0
    
    def backtest_signals(self, df: pd.DataFrame, asset: str) -> dict:
        """
        Backtest the signals generated by the indicator
        
        Returns metrics: win_rate, avg_return, sharpe, total_return, num_trades
        """
        df_signals = df[df['signal'] != 0].copy()
        
        if len(df_signals) == 0:
            return {
                'win_rate': 0,
                'avg_return': 0,
                'sharpe': 0,
                'total_return': 0,
                'num_trades': 0,
                'avg_win': 0,
                'avg_loss': 0
            }
        
        # Calculate returns for each signal (12-hour forward)
        returns = []
        wins = []
        losses = []
        
        for idx in df_signals.index:
            if idx + 12 >= len(df):
                continue
            
            entry_price = df.loc[idx, 'close']
            exit_price = df.loc[idx + 12, 'close']
            signal = df.loc[idx, 'signal']
            
            # Calculate return based on signal direction
            if signal == 1:  # LONG
                ret = (exit_price - entry_price) / entry_price
            else:  # SHORT
                ret = (entry_price - exit_price) / entry_price
            
            returns.append(ret)
            if ret > 0:
                wins.append(ret)
            else:
                losses.append(ret)
        
        if len(returns) == 0:
            return {
                'win_rate': 0,
                'avg_return': 0,
                'sharpe': 0,
                'total_return': 0,
                'num_trades': 0,
                'avg_win': 0,
                'avg_loss': 0
            }
        
        returns = np.array(returns)
        win_rate = len(wins) / len(returns) if len(returns) > 0 else 0
        avg_return = returns.mean()
        sharpe = returns.mean() / returns.std() if returns.std() > 0 else 0
        total_return = (1 + returns).prod() - 1
        
        return {
            'win_rate': win_rate,
            'avg_return': avg_return,
            'sharpe': sharpe,
            'total_return': total_return,
            'num_trades': len(returns),
            'avg_win': np.mean(wins) if len(wins) > 0 else 0,
            'avg_loss': np.mean(losses) if len(losses) > 0 else 0
        }
    
    def optimize_grid_search(
        self,
        param_grid: dict,
        target_metric: str = 'sharpe',
        min_trades: int = 5
    ):
        """
        Perform grid search over parameter combinations
        
        Args:
            param_grid: Dict of parameter names to lists of values
            target_metric: 'sharpe', 'win_rate', 'avg_return', or 'total_return'
            min_trades: Minimum number of trades required
        
        Returns:
            Best parameters for each asset + universal best
        """
        print(f"\nüîç Starting Grid Search Optimization...")
        print(f"   Target metric: {target_metric}")
        print(f"   Min trades: {min_trades}")
        
        # Generate all parameter combinations
        param_names = list(param_grid.keys())
        param_values = [param_grid[name] for name in param_names]
        combinations = list(product(*param_values))
        
        print(f"   Testing {len(combinations)} parameter combinations...")
        
        # Store all results
        all_results = []
        
        for i, combo in enumerate(combinations):
            params = dict(zip(param_names, combo))
            
            if (i + 1) % 10 == 0:
                print(f"   Progress: {i+1}/{len(combinations)}...")
            
            # Test on each asset
            asset_results = {}
            
            for asset in self.data.keys():
                try:
                    # Create indicator with these parameters
                    rbo = RubberBandOscillator(**params)
                    
                    # Calculate signals
                    df_result = rbo.calculate(self.data[asset])
                    
                    # Backtest
                    metrics = self.backtest_signals(df_result, asset)
                    
                    asset_results[asset] = metrics
                    
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Error with {asset}, params {params}: {e}")
                    asset_results[asset] = {
                        'win_rate': 0, 'avg_return': 0, 'sharpe': 0,
                        'total_return': 0, 'num_trades': 0
                    }
            
            # Calculate universal metric (average across assets)
            valid_assets = [a for a in asset_results if asset_results[a]['num_trades'] >= min_trades]
            
            if len(valid_assets) > 0:
                universal_metric = np.mean([asset_results[a][target_metric] for a in valid_assets])
            else:
                universal_metric = -999
            
            result = {
                'params': params,
                'asset_results': asset_results,
                'universal_metric': universal_metric,
                'valid_assets': len(valid_assets)
            }
            
            all_results.append(result)
        
        self.results = all_results
        
        # Find best parameters for each asset
        best_per_asset = {}
        for asset in self.data.keys():
            valid_results = [
                r for r in all_results 
                if r['asset_results'][asset]['num_trades'] >= min_trades
            ]
            
            if len(valid_results) > 0:
                best = max(valid_results, key=lambda x: x['asset_results'][asset][target_metric])
                best_per_asset[asset] = {
                    'params': best['params'],
                    'metrics': best['asset_results'][asset]
                }
            else:
                best_per_asset[asset] = None
        
        # Find universal best
        valid_universal = [r for r in all_results if r['valid_assets'] >= len(self.data)]
        if len(valid_universal) > 0:
            best_universal = max(valid_universal, key=lambda x: x['universal_metric'])
        else:
            best_universal = None
        
        return {
            'best_per_asset': best_per_asset,
            'best_universal': best_universal,
            'all_results': all_results
        }
    
    def print_results(self, optimization_results: dict):
        """Print optimization results in a readable format"""
        print("\n" + "="*80)
        print("üìä RUBBER-BAND INDICATOR - OPTIMIZATION RESULTS")
        print("="*80)
        
        # Best per asset
        print("\nüéØ BEST PARAMETERS PER ASSET:\n")
        for asset, result in optimization_results['best_per_asset'].items():
            if result is None:
                print(f"‚ùå {asset}: No valid results (insufficient trades)")
                continue
            
            print(f"{'='*60}")
            print(f"  {asset}")
            print(f"{'='*60}")
            print(f"  Parameters:")
            for param, value in result['params'].items():
                print(f"    {param}: {value}")
            
            print(f"\n  Performance:")
            m = result['metrics']
            print(f"    Win Rate:     {m['win_rate']*100:.1f}%")
            print(f"    Avg Return:   {m['avg_return']*100:.3f}%")
            print(f"    Sharpe Ratio: {m['sharpe']:.3f}")
            print(f"    Total Return: {m['total_return']*100:.2f}%")
            print(f"    Num Trades:   {m['num_trades']}")
            print(f"    Avg Win:      {m['avg_win']*100:.3f}%")
            print(f"    Avg Loss:     {m['avg_loss']*100:.3f}%")
            print()
        
        # Best universal
        if optimization_results['best_universal']:
            print(f"\n{'='*80}")
            print("üåç BEST UNIVERSAL PARAMETERS (all assets):")
            print(f"{'='*80}")
            
            best = optimization_results['best_universal']
            print(f"\nParameters:")
            for param, value in best['params'].items():
                print(f"  {param}: {value}")
            
            print(f"\nPerformance by Asset:")
            for asset, metrics in best['asset_results'].items():
                print(f"\n  {asset}:")
                print(f"    Win Rate:     {metrics['win_rate']*100:.1f}%")
                print(f"    Avg Return:   {metrics['avg_return']*100:.3f}%")
                print(f"    Sharpe Ratio: {metrics['sharpe']:.3f}")
                print(f"    Total Return: {metrics['total_return']*100:.2f}%")
                print(f"    Num Trades:   {metrics['num_trades']}")
            
            print(f"\n  Universal Metric: {best['universal_metric']:.3f}")
        else:
            print("\n‚ö†Ô∏è  No universal parameters found (need valid results for all assets)")
    
    def save_results(self, optimization_results: dict, filename: str = None):
        """Save optimization results to JSON"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"rubberband_optimization_{timestamp}.json"
        
        # Convert to JSON-serializable format
        output = {
            'timestamp': datetime.now().isoformat(),
            'assets': self.assets,
            'best_per_asset': {},
            'best_universal': None
        }
        
        for asset, result in optimization_results['best_per_asset'].items():
            if result:
                output['best_per_asset'][asset] = {
                    'params': result['params'],
                    'metrics': result['metrics']
                }
        
        if optimization_results['best_universal']:
            best = optimization_results['best_universal']
            output['best_universal'] = {
                'params': best['params'],
                'asset_results': best['asset_results'],
                'universal_metric': best['universal_metric']
            }
        
        with open(filename, 'w') as f:
            json.dump(output, f, indent=2)
        
        print(f"\nüíæ Results saved to: {filename}")
        return filename


if __name__ == "__main__":
    """
    Run optimization with sensible parameter ranges
    """
    
    print("="*80)
    print("üéØ RUBBER-BAND INDICATOR - PARAMETER OPTIMIZATION")
    print("="*80)
    
    # Initialize optimizer
    optimizer = RubberBandOptimizer(assets=['BTC', 'ETH', 'SOL'])
    
    # Load data
    if not optimizer.load_data():
        print("‚ùå Failed to load data")
        exit(1)
    
    # Define parameter grid (start with key parameters)
    param_grid = {
        'z_lookback': [150, 200, 250],           # Z-score calculation window
        'up_threshold': [1.5, 2.0, 2.5],         # Overbought threshold
        'down_threshold': [-2.5, -2.0, -1.5],    # Oversold threshold
        'smooth_len': [3, 5, 7],                 # EMA smoothing
        'min_bars_between': [5, 8, 12],          # Signal cooldown
        'use_dynamic_thresholds': [True],        # Always use ATR adjustment
        'use_keltner_filter': [True],            # Always use Keltner filter
        'use_adaptive_weights': [False]          # Keep off for speed
    }
    
    print(f"\nüìã Parameter Grid:")
    for param, values in param_grid.items():
        print(f"   {param}: {values}")
    
    total_combinations = 1
    for values in param_grid.values():
        total_combinations *= len(values)
    print(f"\n   Total combinations to test: {total_combinations}")
    
    # Run optimization
    results = optimizer.optimize_grid_search(
        param_grid=param_grid,
        target_metric='sharpe',  # Optimize for risk-adjusted returns
        min_trades=5             # Need at least 5 trades
    )
    
    # Print results
    optimizer.print_results(results)
    
    # Save results
    optimizer.save_results(results)
    
    print("\n‚úÖ Optimization complete!")
